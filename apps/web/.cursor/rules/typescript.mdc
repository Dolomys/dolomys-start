---
description: 
globs: 
alwaysApply: true
---
# Conventions TypeScript

## Configuration

Nous utilisons TypeScript en mode strict avec les configurations suivantes :

```json title="tsconfig.json"
{
  "compilerOptions": {
    "strict": true,
    "noImplicitAny": true,
    "strictNullChecks": true
  }
}
```

## Types vs Interfaces

### Quand Utiliser `type`

```typescript
// âœ… Pour les unions
type Status = "pending" | "success" | "error";

// âœ… Pour les types utilitaires
type Nullable<T> = T | null;

// âœ… Pour les types complexes
type UserWithPosts = {
  user: User;
  posts: Post[];
};
```

### Quand Utiliser `interface`

```typescript
// âœ… Pour les objets de donnÃ©es
interface User {
  id: string;
  name: string;
}

// âœ… Pour l'hÃ©ritage
interface AdminUser extends User {
  permissions: string[];
}

// âœ… Pour les props de composants
interface ButtonProps {
  variant: "primary" | "secondary";
  onClick: () => void;
}
```

## Bonnes Pratiques

### 1. Nommage Explicite

```typescript
// âœ… Bon
interface CreateUserParams {
  email: string;
  password: string;
}

// ðŸš« Ã€ Ã©viter
interface Params {
  email: string;
  password: string;
}
```

### 2. GÃ©nÃ©riques

```typescript
// âœ… Bon
interface ApiResponse<T> {
  data: T;
  status: number;
}

// Usage
const response: ApiResponse<User> = await api.get("/user");
```

### 3. Type Inference

```typescript
// âœ… Bon
const users = ["John", "Jane"]; // type: string[]

// ðŸš« Ã€ Ã©viter
const users: string[] = ["John", "Jane"];
```

## Pattern React Query

### Types de ParamÃ¨tres

```typescript
interface GetUsersParams {
  page?: number;
  limit?: number;
  search?: string;
}
```

### Types de RÃ©ponse

```typescript
interface User {
  id: string;
  name: string;
}

interface ApiResponse<T> {
  data: T;
  meta: {
    total: number;
    page: number;
  };
}

// Usage
const getUsers = async (params: GetUsersParams): Promise<ApiResponse<User[]>> => {
  const response = await api.get("/users", { params });
  return response.data;
};
```

## Types Utilitaires

### Helpers Communs

```typescript
// Rendre toutes les propriÃ©tÃ©s optionnelles
type Partial<T> = {
  [P in keyof T]?: T[P];
};

// Rendre toutes les propriÃ©tÃ©s requises
type Required<T> = {
  [P in keyof T]-?: T[P];
};

// Rendre toutes les propriÃ©tÃ©s en lecture seule
type Readonly<T> = {
  readonly [P in keyof T]: T[P];
};
```

### Types PersonnalisÃ©s

```typescript
// Type pour les props de style
type StyleProps = {
  className?: string;
  style?: React.CSSProperties;
};

// Type pour les handlers d'Ã©vÃ©nements
type EventHandler<T = Element> = (event: React.SyntheticEvent<T>) => void;

// Type pour les refs
type Ref<T> = React.RefObject<T> | ((instance: T | null) => void);
```

:::tip Conseil
Utilisez les types utilitaires de TypeScript quand c'est possible plutÃ´t que de rÃ©inventer la roue.
:::

## Validation des Types

### zod

Nous utilisons `zod` pour la validation des donnÃ©es :

```typescript
import { z } from "zod";

const UserSchema = z.object({
  id: z.string(),
  email: z.string().email(),
  age: z.number().min(0),
});

type User = z.infer<typeof UserSchema>;
```
